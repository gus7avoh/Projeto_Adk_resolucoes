# Imports corretos para Google ADK
from google.adk.agents import LlmAgent
from google.adk.agents import Agent
from google.adk.models.lite_llm import LiteLlm
import os
import json
from pathlib import Path
from dotenv import load_dotenv
from pdf2docx import Converter
from docx import Document
from typing import Dict, List, Optional, Tuple
import logging

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

load_dotenv()

# Configura√ß√£o dos caminhos - usando vari√°veis de ambiente para flexibilidade
BASE_PATH = os.getenv('DOCUMENTS_PATH', r"D:\cod\Arsae\Adk\Projeto_Adk_resolucoes\Adm_agentes\documentos")
CACHE_FILE = os.path.join(BASE_PATH, "cache_processamento.json")

# ========================================
# FUN√á√ïES UTILIT√ÅRIAS MELHORADAS
# ========================================

def ensure_directories() -> bool:
    """Garante que os diret√≥rios necess√°rios existam."""
    try:
        os.makedirs(BASE_PATH, exist_ok=True)
        logger.info(f"Diret√≥rio garantido: {BASE_PATH}")
        return True
    except Exception as e:
        logger.error(f"Erro ao criar diret√≥rios: {str(e)}")
        return False

def list_pdfs() -> List[str]:
    """Lista todos os arquivos PDF dispon√≠veis."""
    try:
        if not os.path.exists(BASE_PATH):
            logger.warning(f"Diret√≥rio {BASE_PATH} n√£o existe.")
            return []
        
        pdfs = [f for f in os.listdir(BASE_PATH) if f.lower().endswith('.pdf')]
        logger.info(f"Encontrados {len(pdfs)} arquivos PDF")
        return pdfs
    
    except Exception as e:
        logger.error(f"Erro ao listar arquivos: {str(e)}")
        return []

def converter_pdf_para_docx(pdf_path: str, docx_path: str) -> bool:
    """
    Converte um arquivo PDF para DOCX.
    """
    try:
        if not os.path.exists(pdf_path):
            logger.error(f"Arquivo PDF n√£o encontrado: {pdf_path}")
            return False
        
        # Verificar se o arquivo DOCX j√° existe e √© mais recente
        if os.path.exists(docx_path):
            pdf_time = os.path.getmtime(pdf_path)
            docx_time = os.path.getmtime(docx_path)
            if docx_time > pdf_time:
                logger.info(f"DOCX j√° existe e √© mais recente: {os.path.basename(docx_path)}")
                return True
            
        cv = Converter(pdf_path)
        cv.convert(docx_path)
        cv.close()
        logger.info(f"PDF convertido com sucesso: {os.path.basename(pdf_path)}")
        return True
        
    except Exception as e:
        logger.error(f"Erro ao converter PDF para DOCX ({os.path.basename(pdf_path)}): {str(e)}")
        return False

def analisar_estrutura_documento(docx_path: str) -> Dict:
    """
    Analisa a estrutura completa do documento DOCX.
    Retorna tanto texto riscado quanto normal com metadados.
    """
    try:
        if not os.path.exists(docx_path):
            logger.error(f"Arquivo DOCX n√£o encontrado: {docx_path}")
            return {"erro": "Arquivo n√£o encontrado"}
        
        doc = Document(docx_path)
        resultado = {
            "paragrafos": [],
            "estatisticas": {
                "total_paragrafos": 0,
                "paragrafos_com_texto_riscado": 0,
                "paragrafos_normais": 0,
                "palavras_total": 0
            },
            "metadados": {
                "arquivo": os.path.basename(docx_path),
                "caminho": docx_path,
                "tamanho_arquivo": os.path.getsize(docx_path)
            }
        }

        for i, paragraph in enumerate(doc.paragraphs):
            texto = paragraph.text.strip()
            if not texto:
                continue

            # Analisar formata√ß√£o
            tem_risco = any(run.font.strike for run in paragraph.runs)
            
            paragrafo_info = {
                "numero": i + 1,
                "texto": texto,
                "tem_texto_riscado": tem_risco,
                "palavras": len(texto.split()),
                "caracteres": len(texto)
            }
            
            resultado["paragrafos"].append(paragrafo_info)
            
            # Atualizar estat√≠sticas
            resultado["estatisticas"]["total_paragrafos"] += 1
            resultado["estatisticas"]["palavras_total"] += paragrafo_info["palavras"]
            
            if tem_risco:
                resultado["estatisticas"]["paragrafos_com_texto_riscado"] += 1
            else:
                resultado["estatisticas"]["paragrafos_normais"] += 1

        logger.info(f"An√°lise completa do documento: {os.path.basename(docx_path)} - "
                   f"{resultado['estatisticas']['total_paragrafos']} par√°grafos processados")
        
        return resultado

    except Exception as e:
        logger.error(f"Erro ao analisar documento DOCX: {str(e)}")
        return {"erro": str(e)}

def salvar_cache(dados: Dict) -> bool:
    """Salva os dados processados em cache."""
    try:
        with open(CACHE_FILE, 'w', encoding='utf-8') as f:
            json.dump(dados, f, ensure_ascii=False, indent=2)
        logger.info(f"Cache salvo em: {CACHE_FILE}")
        return True
    except Exception as e:
        logger.error(f"Erro ao salvar cache: {str(e)}")
        return False

def carregar_cache() -> Optional[Dict]:
    """Carrega dados do cache se existir."""
    try:
        if os.path.exists(CACHE_FILE):
            with open(CACHE_FILE, 'r', encoding='utf-8') as f:
                dados = json.load(f)
            logger.info("Cache carregado com sucesso")
            return dados
    except Exception as e:
        logger.error(f"Erro ao carregar cache: {str(e)}")
    return None

def processar_pdf_completo() -> Dict:
    """
    Processa todos os PDFs com an√°lise completa e cache.
    """
    # Garantir que os diret√≥rios existam
    if not ensure_directories():
        return {"erro": "N√£o foi poss√≠vel criar/acessar os diret√≥rios necess√°rios"}
    
    # Tentar carregar do cache primeiro
    cache_data = carregar_cache()
    if cache_data and cache_data.get("sucesso"):
        logger.info("Dados carregados do cache")
        return cache_data
    
    resultados = {}
    arquivos_pdf = list_pdfs()
    
    if not arquivos_pdf:
        return {"erro": "Nenhum arquivo PDF encontrado", "arquivos_processados": 0}
    
    logger.info(f"Iniciando processamento de {len(arquivos_pdf)} arquivos PDF")
    
    for arquivo_pdf in arquivos_pdf:
        logger.info(f"Processando: {arquivo_pdf}")
        
        # Construir caminhos completos
        pdf_path = os.path.join(BASE_PATH, arquivo_pdf)
        nome_base = os.path.splitext(arquivo_pdf)[0]
        docx_path = os.path.join(BASE_PATH, f"{nome_base}.docx")
        
        # Converter PDF para DOCX
        sucesso_conversao = converter_pdf_para_docx(pdf_path, docx_path)
        
        if sucesso_conversao:
            # Analisar estrutura completa
            resultado_analise = analisar_estrutura_documento(docx_path)
            resultados[arquivo_pdf] = {
                "convertido": True,
                "caminho_docx": docx_path,
                "analise_completa": resultado_analise,
                "status": "sucesso"
            }
        else:
            resultados[arquivo_pdf] = {
                "convertido": False,
                "erro": "Falha na convers√£o",
                "analise_completa": None,
                "status": "erro"
            }
    
    # Preparar resultado final
    resultado_final = {
        "arquivos_processados": len(resultados),
        "arquivos_com_sucesso": len([r for r in resultados.values() if r["status"] == "sucesso"]),
        "resultados": resultados,
        "sucesso": True,
        "timestamp": os.path.getctime(CACHE_FILE) if os.path.exists(CACHE_FILE) else None
    }
    
    # Salvar no cache
    salvar_cache(resultado_final)
    
    logger.info(f"Processamento conclu√≠do. {len(resultados)} arquivos processados.")
    return resultado_final

def obter_dados_para_analise() -> Dict:
    """
    Obt√©m os dados processados formatados especificamente para an√°lise de contradi√ß√µes.
    """
    dados_brutos = processar_pdf_completo()
    
    if not dados_brutos.get("sucesso"):
        return dados_brutos
    
    # Formatar dados para an√°lise
    dados_formatados = {
        "documentos": {},
        "estatisticas_gerais": {
            "total_documentos": dados_brutos["arquivos_processados"],
            "documentos_processados": dados_brutos["arquivos_com_sucesso"],
            "total_paragrafos": 0,
            "total_palavras": 0
        }
    }
    
    for arquivo, resultado in dados_brutos["resultados"].items():
        if resultado["status"] == "sucesso" and resultado["analise_completa"]:
            analise = resultado["analise_completa"]
            
            # Extrair apenas texto normal (n√£o riscado) para an√°lise
            textos_normais = [
                p["texto"] for p in analise["paragrafos"] 
                if not p["tem_texto_riscado"] and p["texto"].strip()
            ]
            
            dados_formatados["documentos"][arquivo] = {
                "nome": arquivo,
                "textos": textos_normais,
                "total_paragrafos": len(textos_normais),
                "estatisticas": analise["estatisticas"]
            }
            
            # Atualizar estat√≠sticas gerais
            dados_formatados["estatisticas_gerais"]["total_paragrafos"] += len(textos_normais)
            dados_formatados["estatisticas_gerais"]["total_palavras"] += analise["estatisticas"]["palavras_total"]
    
    return dados_formatados

# ========================================
# CONFIGURA√á√ÉO DOS AGENTES OTIMIZADA
# ========================================

# Agent especializado em an√°lise de contradi√ß√µes
Contradicao = Agent(
    model="gemini-2.0-flash",
    name="Contradicao",
    description="Especialista em an√°lise de contradi√ß√µes em resolu√ß√µes documentais",
    instruction="""
    Voc√™ √© um especialista em an√°lise de contradi√ß√µes em documentos regulat√≥rios.

    N√£o precisa ter pressa, pode analizar com calma.
    
    FUN√á√ïES DISPON√çVEIS:
    - list_pdfs() -> Lista arquivos PDF dispon√≠veis
    - processar_pdf_completo() -> Processa todos os PDFs com an√°lise completa
    - obter_dados_para_analise() -> Obt√©m dados formatados para an√°lise
    
    INSTRU√á√ïES PRINCIPAIS:
    
    1. SEMPRE comece chamando obter_dados_para_analise() para obter os dados processados
    2. Analise TODOS os textos extra√≠dos buscando contradi√ß√µes
    3. Foque apenas em texto normal (n√£o riscado) pois representa a vers√£o atual das resolu√ß√µes
    
    DEFINI√á√ÉO DE CONTRADI√á√ÉO:
    Uma contradi√ß√£o ocorre quando dois ou mais trechos fazem afirma√ß√µes opostas sobre:
    - O mesmo assunto/t√≥pico
    - No mesmo contexto temporal
    - Com aplicabilidade similar
    
    METODOLOGIA DE AN√ÅLISE:
    1. Agrupe textos por temas/assuntos similares
    2. Compare afirma√ß√µes dentro de cada grupo
    3. Identifique declara√ß√µes conflitantes
    4. Verifique se o contexto √© realmente compar√°vel
    5. Documente contradi√ß√µes encontradas
    
    FORMATO DE RESPOSTA:
    ```
    RELAT√ìRIO DE AN√ÅLISE DE CONTRADI√á√ïES
    =====================================
    
    üìä RESUMO EXECUTIVO:
    - Documentos analisados: [quantidade]
    - Par√°grafos processados: [quantidade]
    - Contradi√ß√µes identificadas: [quantidade]
    
    üîç CONTRADI√á√ïES ENCONTRADAS:
    
    [Para cada contradi√ß√£o:]
    
    Contradi√ß√£o #[n√∫mero]:
    ----------------------
    üìÑ Documento A: [nome do arquivo]
    üìç Localiza√ß√£o: [par√°grafo/se√ß√£o]
    üìù Texto: "[trecho exato]"
    
    üìÑ Documento B: [nome do arquivo]
    üìç Localiza√ß√£o: [par√°grafo/se√ß√£o]
    üìù Texto: "[trecho exato]"
    
    üîç An√°lise da Contradi√ß√£o:
    [Explica√ß√£o clara de como os textos se contradizem]
    
    üìä CONCLUS√ÉO:
    [Resumo final dos achados]
    ```
    
    IMPORTANTE:
    - Seja rigoroso na identifica√ß√£o de contradi√ß√µes
    - Cite sempre os trechos exatos
    - Explique claramente por que constitui uma contradi√ß√£o
    - Se n√£o encontrar contradi√ß√µes, declare claramente
    - Trabalhe de forma met√≥dica e completa
    """,
    tools=[list_pdfs, processar_pdf_completo, obter_dados_para_analise],
    output_key="relatorio_contradicoes"
)

# Agent coordenador e validador
Coordenador = Agent(
    model="gemini-2.0-flash",
    name="Coordenador",
    description="Coordenador respons√°vel pela gest√£o e valida√ß√£o do processo de an√°lise",
    instruction="""
    Voc√™ √© o coordenador respons√°vel por gerenciar todo o processo de an√°lise de contradi√ß√µes.

    N√£o precisa ter pressa, pode analizar com calma.
    
    FUN√á√ïES DISPON√çVEIS:
    - list_pdfs() -> Lista arquivos PDF dispon√≠veis
    - processar_pdf_completo() -> Processa todos os PDFs
    - obter_dados_para_analise() -> Obt√©m dados para an√°lise
    
    PROCESSO DE COORDENA√á√ÉO:
    
    1. INICIALIZA√á√ÉO:
       - Verificar arquivos dispon√≠veis
       - Iniciar processamento se necess√°rio
       - Coordenar com o agente Contradicao
    
    2. SUPERVIS√ÉO:
       - Monitorar o progresso da an√°lise
       - Acessar resultados via 'relatorio_contradicoes'
       - Validar qualidade dos resultados
    
    3. VALIDA√á√ÉO:
       - Verificar se a an√°lise foi completa
       - Validar se contradi√ß√µes s√£o leg√≠timas
       - Confirmar que o formato est√° correto
       - Identificar poss√≠veis melhorias
    
    4. RELAT√ìRIO FINAL:
       - Consolidar todos os resultados
       - Fornecer avalia√ß√£o da qualidade
       - Sugerir pr√≥ximos passos se necess√°rio
    
    FORMATO DE RESPOSTA FINAL:
    ```
    RELAT√ìRIO DE COORDENA√á√ÉO E VALIDA√á√ÉO
    ===================================
    
    ‚úÖ STATUS DO PROCESSO: [CONCLU√çDO/PENDENTE/ERRO]
    
    üìã RESUMO EXECUTIVO:
    - Arquivos PDF encontrados: [X]
    - Arquivos processados: [X]
    - An√°lise de contradi√ß√µes: [REALIZADA/PENDENTE]
    - Contradi√ß√µes validadas: [X]
    
    üîç VALIDA√á√ÉO DOS RESULTADOS:
    [Avalia√ß√£o detalhada da qualidade da an√°lise]
    
    üìä ESTAT√çSTICAS FINAIS:
    - Total de par√°grafos analisados: [X]
    - Contradi√ß√µes identificadas: [X]
    - Confiabilidade da an√°lise: [ALTA/M√âDIA/BAIXA]
    
    üí° RECOMENDA√á√ïES:
    [Sugest√µes para melhorias ou pr√≥ximos passos]
    
    üìÅ ARQUIVOS GERADOS:
    - Cache de processamento: [status]
    - Relat√≥rio de an√°lise: [status]
    ```
    
    COORDENA√á√ÉO COM SUB-AGENTES:
    - Ative o agente Contradicao automaticamente
    - Aguarde conclus√£o da an√°lise
    - Valide os resultados obtidos
    - Forne√ßa feedback final consolidado
    """,
    sub_agents=[Contradicao],
    tools=[list_pdfs, processar_pdf_completo, obter_dados_para_analise],
    output_key="relatorio_final_coordenacao"
)

# Definir o agente raiz
root_agent = Coordenador